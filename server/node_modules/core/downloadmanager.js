const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

function uid(len) {
	len = len || 7;
	return Math.random().toString(35).substr(2, len);
};

class PendingDownload {
	constructor(var1) {
		let self = this;
		let download_manager = DownloadManager.getInstance();
		let user = var1.user;
		let socket = user.getSocket();

		let max_chunk_size = Math.pow(10, 3) * 32;

		let parsed_file = path.parse(var1.file.name);
		let checksums = var1.file.checksums;
		let corrupt_count = 0;

		let tmp_filename;
		do {
			tmp_filename = uid(7)
		} while(fs.existsSync('./server/uploads/tmp/' + tmp_filename) || fs.existsSync('./server/uploads/' + tmp_filename));

		let file = {
			size : var1.file.size,
			name : parsed_file.name,
			ext : parsed_file.ext
		};

		let stream = fs.createWriteStream('./server/uploads/tmp/' + tmp_filename);

		let passes = 0;
		let max_passes = Math.ceil(var1.file.size / max_chunk_size);

		user.notify({
			action : "upload_wait_data"
		});

		let message_listener = (data) => {
			if(data instanceof Buffer) {
				if(!(checksums[passes] === crypto.createHash('md5').update(data.toLocaleString()).digest('hex'))) {
					corrupt_count++;

					if(!(corrupt_count < 5)) {
						stream.end();
						fs.unlink('./server/uploads/tmp/' + tmp_filename);

						user.notify({
							action : "upload_abort"
						});

						download_manager.removeDownload(self);
						socket.removeListener('message', message_listener);

						return;
					}

					user.notify({
						action : "upload_fragment_corrupted",
						extra : {
							fragment : passes
						}
					});

					return;
				}

				stream.write(data);
				if(++passes == max_passes) {
					stream.end();
					fs.renameSync('./server/uploads/tmp/' + tmp_filename, './server/uploads/' + tmp_filename);

					user.notify({
						action : "upload_finished"
					});

					download_manager.addCompleteDownload({
						file : {
							name : file.name,
							size : file.size,
							ext : file.ext,
							tmp_name : tmp_filename
						},
						user : var1.user
					});

					download_manager.removeDownload(self);

					socket.removeListener('message', message_listener);

					return;
				}

				user.notify({
					action : "upload_wait_data"
				});
			}
		};

		socket.on('message', message_listener);
	};
};

class DownloadManager {
	constructor() {
		this._downloads = [];
		this._pending_downloads = [];
	};

	/**
	 * @param {Object} var1
	 * @param {User} var1.user
	 * @param {Object} var1.file
	 * @param {String} var1.file.name
	 * @param {Integer} var1.file.size
	 */
	addDownload(var1) {
		// is valid
		this._pending_downloads.push(new PendingDownload(var1));
	};

	removeDownload(var1) {
		let index = this._pending_downloads.indexOf(var1);

		if(index < 0) {
			return;
		}

		this._pending_downloads.splice(index, 1);
	};

	/**
	 * @param {Object} var1
	 * @param {User} var1.user
	 * @param {Object} var1.file
	 * @param {String} var1.file.name
	 * @param {String} var1.file.tmp_filename
	 * @param {Integer} var1.file.size
	 */
	addCompleteDownload(var1) {
		this._downloads.push(var1);

		let formatted_download = {
			action : 'new_download',
			extra : {
				file : {
					name : var1.file.name,
					ext : var1.file.ext,
					size : var1.file.size,
					access : var1.file.tmp_name,
					pubdate : new Date().toISOString()
				},
				user: {
					username : var1.user.getUsername()
				}
			}
		};

		let channel = var1.user.getChannel()

		channel.addDownload(formatted_download);
		channel.notify(formatted_download);
	};

	static getInstance() {
		if(this._instance === null) {
			this._instance = new DownloadManager();
		}

		return this._instance;
	};
};

DownloadManager._instance = null;

module.exports = DownloadManager;