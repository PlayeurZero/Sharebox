const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

class PendingDownload {
	constructor(var1) {
		let parsed_file = path.parse(var1.file.name);
		let checksums = var1.file.checksums;

		let file = {
			size : var1.file.size,
			name : parsed_file.name,
			ext : parsed_file.ext
		};

		let stream = fs.createWriteStream('./server/uploads/' + file.name + file.ext);

		let passes = 0;
		let max_passes = Math.ceil(var1.file.size / 16384);

		let user = var1.user;

		user.notify(JSON.stringify({
			action : "upload_wait_data"
		}));

		user.getSocket().on('message', (data) => {
			if(data instanceof Buffer) {
				if(!(checksums[passes] === crypto.createHash('md5').update(data.toLocaleString()).digest('hex'))) {
					user.notify(JSON.stringify({
						action : "upload_fragment_corrupted",
						extra : {
							fragment : passes
						}
					}));

					return;
				}

				stream.write(data);
				if(++passes == max_passes) {
					stream.end();

					user.notify(JSON.stringify({
						action : "upload_finished"
					}));

					return;
				}

				user.notify(JSON.stringify({
					action : "upload_wait_data"
				}));
			}
		});
	};
};

class DownloadManager {
	constructor() {
		this._downloads = [];
		this._pending_downloads = [];
	}

	/**
	 * @param {Object} var1
	 * @param {String} var1.name
	 * @param {Integer} var1.size
	 */
	addDownload(var1) {
		// is valid
		this._pending_downloads.push(new PendingDownload(var1));
	};
	
	static getInstance() {
		if(this._instance === null) {
			this._instance = new DownloadManager();
		}

		return this._instance;
	};
};

DownloadManager._instance = null;

module.exports = DownloadManager;