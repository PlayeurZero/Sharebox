const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
let SocketServer = require('core/socketserver');
let GroupManager = require('core/groupmanager').GroupManager;

class User {
	/**
	 * @constructor
	 * @param {Object} var1
	 */
	constructor(var1) {
		this._socket = var1.socket;
		this._username = var1.username;
		this._avatar = var1.avatar;
		this._group = null;
		this._permissions = null;
		this._logged = false;
	};

	/**
	 * @param {Websocket} var1
	 */
	setSocket(var1) {
		this._socket = var1;
	};

	/**
	 * @param {string} var1
	 */
	setUsername(var1) {
		this._username = var1;
	};

	/**
	 * @param {integer} var1
	 */
	setAvatar(var1) {
		this._avatar = var1;
	};

	/**
	 * @param {Group} var1
	 */
	setGroup(var1) {
		this._group = var1;
	};

	/**
	 * @param {Array.<string>} var1
	 */
	setPermissions(var1) {
		this._permissions = var1;
	};

	/**
	 * @param {boolean} var1
	 */
	setLogged(var1) {
		this._logged = var1;
	};

	/**
	 * @return {WebSocket}
	 */
	getSocket() {
		return this._socket;
	};

	/**
	 * @return {string}
	 */
	getUsername() {
		return this._username;
	};

	/**
	 * @return {string}
	 */
	getAvatar() {
		return this._avatar;
	};

	/**
	 * @return {string}
	 */
	getGroup() {
		return this._group;
	};

	/**
	 * @return {Array.<string>}
	 */
	getPermissions() {
		return this._permissions;
	};

	/**
	 * @return {boolean}
	 */
	isLogged() {
		return this._logged;
	};

	getChannel() {
		return ChannelManager.getInstance().getUserChannel(this);
	};

	/**
	 * @param {String} var1
	 */
	notify(var1) {
		try {
			this._socket.send(var1);
		} catch(e) {};
	};

	/**
	 * @param {Object} var1
	 * @param {string} var1.username
	 * @param {string} var1.password
	 */
	signin(var1) {
		let self = this;

		if(this.isLogged()) {
			self.notify(JSON.stringify({
				action : "signup_failed",
				extra : {
					message : "translate:user/already_logged"
				}
			}));

			return;
		}

		if(!(typeof var1.username === 'string' && typeof var1.password === 'string')) {
			self.notify(JSON.stringify({
				action : "signin_failed",
				extra : {
					message : "translate:user/bad_request"
				}
			}));

			return;
		}

		if(User.isLogged(var1.username)) {
			self.notify(JSON.stringify({
				action : "signin_failed",
				extra : {
					message : "translate:user/already_used_account"
				}
			}));

			return;
		}

		User.validateCredentials({
			username : var1.username,
			password : var1.password,
			callback : (err, user_data) => {
				if(err) {
					self.notify(JSON.stringify({
						action : "signin_failed",
						extra : {
							message : err
						}
					}));
					return;
				}

				self.setLogged(true);
				self.setUsername(user_data.username);
				self.setAvatar(user_data.avatar);
				self.setPermissions(user_data.access.permissions);
				self.setGroup(GroupManager.getInstance().getGroup(user_data.access.group));
				ChannelManager.getInstance().getDefaultChannel().addUser({
					user : self,
					force : false,
					callback : () => {}
				});

				self.notify(JSON.stringify({
					action : "signin_success",
					extra : {
						message : "translate:user/signin_success",
						username : self.getUsername(),
						avatar : self.getAvatar()
					}
				}));
			}
		});
	};

	/**
	 * @param {Object} var1
	 * @param {string} var1.username
	 * @param {string} var1.password
	 */
	signup(var1) {
		let self = this;

		if(this.isLogged()) {
			self.notify(JSON.stringify({
				action : "signup_failed",
				extra : {
					message : "translate:user/already_logged"
				}
			}))
			return;
		}

		if(!(typeof var1.username === 'string' && typeof var1.password === 'string')) {
			self.notify(JSON.stringify({
				action : "signup_failed",
				extra : {
					message : "translate:user/bad_request"
				}
			}));

			return;
		}

		User.registerUser({
			username : var1.username,
			password : var1.password,
			callback : (err, user_data) => {
				if(err) {
					self.notify(JSON.stringify({
						action : "signup_failed",
						extra : {
							message : err
						}
					}));

					return;
				}

				self.setLogged(true);
				self.setUsername(user_data.username);
				self.setAvatar(user_data.avatar);
				self.setGroup(user_data.access.group);
				self.setPermissions(user_data.access.permissions);
				ChannelManager.getInstance().getDefaultChannel().addUser(self);

				self.notify(JSON.stringify({
					action : "signup_success",
					extra : {
						message : "translate:user/signup_success",
						username : self.getUsername(),
						avatar : self.getAvatar()
					}
				}));
			}
		});
	};

	signout() {
		let self = this;

		User.removeUser({
			socket : this.getSocket(),
			callback : (err) => {
				if(err) {
					return;
				}

				self.notify(JSON.stringify({
					"action" : "signout_success",
					extra : {
						message : "translate:user/signout_success"
					}
				}));
			}
		});
	};

	/**
	 * @param {Object} var1
	 * @param {string} var1.message
	 */
	message(var1) {
		let self = this;

		if(!(this.isLogged)) {
			this.notify(JSON.stringify({
				action : "message_failed",
				extra : {
					message : "translate:user/authentification_required"
				}
			}));

			return;
		}

		if(!(typeof var1.message === 'string')) {
			return;
		}

		if(this.getPermissions().indexOf('send_message') < 0) {
			self.notify(JSON.stringify({
				action : "message_failed",
				extra : {
					message : "translate:message/permission_denied"
				}
			}));

			return;
		}
		
		let channel = this.getChannel();

		if(!(channel)) {
			return;
		}

		this.getChannel().notify(JSON.stringify({
			action : "message",
			extra : {
				message : var1.message
			}
		}));
	};

	/**
	 * @param {WebSocket} var1
	 */
	static addUser(var1) {
		let user = new User({ socket : var1 });
		this._users.push(user);

		var1.on('message', (data) => {
			let parsed_data;

			try {
				parsed_data = JSON.parse(data);
			} catch (e) {
				return;
			}

			let action = parsed_data.action;

			switch(action) {
				case "signup" :
					user.signup(parsed_data.extra);
					break;
				
				case "signin" :
					user.signin(parsed_data.extra);
					break;

				case "signout" :
					user.signout(parsed_data.extra);
					break;

				case "message" :
					user.message(parsed_data.extra);
					break;

				case "upload_init" :
					break;

				case "upload_chunk" :
					break;
				
				case "upload_finished" :
					break;

				default:
			}
		});

		var1.on('close', () => {
			this.removeUser({
				user : user,
				callback : () => {}
			});
		});
	};

	/**
	 * @param {Object} var1
	 * @param {User} var1.user
	 * @param {requestCallback} var1.callback
	 */
	static removeUser(var1) {
		let index = this._users.indexOf(var1.user);

		if(index < 0) {
			var1.callback.call(void(0), "ERROR");
			return;
		}

		this._users.splice(index, 1);

		ChannelManager.getInstance().removeUser(var1.user); // TODO

		var1.callback.call(void(0));
	};

	/**
	 * @param {string} var1
	 * @return {boolean}
	 */
	static isLogged(var1) {
		var1 = var1.toLowerCase();

		for(let user of this._users) {
			let username = user.getUsername();

			if(!(typeof username === 'string')) {
				continue;
			}

			if(username.toLowerCase() === var1) {
				return user.isLogged();
			}
		}

		return false;
	};

	/**
	 * @param {Object} var1
	 * @param {string} var1.username
	 * @param {string} var1.password
	 * @param {requestCallback} var1.callback
	 */
	static validateCredentials(var1) {
		let username = var1.username.toLowerCase();
		let password = var1.password;

		if(!(/[A-z][A-z0-9_]+/.test(username))) {
			var1.callback.call(void(0), "translate:user/invalid_username_format");
			return;
		}

		let filepath = path.normalize(process.cwd() + '/server/users/' + username + '.json');
		
		fs.readFile(filepath, (err, data) => {
			if(err) {
				var1.callback.call(void(0), "translate:user/unknown_user");
				return;
			}

			let parsed_data;

			try {
				parsed_data = JSON.parse(data);
			} catch(e) {
				// should not be emitted
				// this error only appear when there is an error with (user) JSON file
				var1.callback.call(void(0), "translate:user/invalid_file_serializing");
				return;
			}

			if(!(parsed_data.password === crypto.createHash("sha256").update(password).update(username).digest("base64"))) {
				var1.callback.call(void(0), "translate:user/invalid_password");
				return;
			}

			if(parsed_data.banned) {
				var1.callback.call(void(0), "translate:user/user_suspended");
				return;
			}

			var1.callback.call(void(0), null, parsed_data);
		});
	};

	/**
	 * @param {Object} var1
	 * @param {string} var1.username
	 * @param {string} var1.password
	 * @param {requestCallback} var1.callback
	 */
	static registerUser(var1) {
		let username = var1.username.toLowerCase();
		let password = var1.password;

		if(!(/[A-z][A-z0-9_]+/.test(username))) {
			var1.callback.call(void(0), "translate:user/invalid_username_format");
			return;
		}

		let filepath = path.normalize(process.cwd() + '/server/users/' + username + '.json');

		fs.stat(filepath, (err, stats) => {
			if(err) {
				let data = {
					username : username,
					password : crypto.createHash("sha256").update(password).update(username).digest("base64"),
					avatar : "0",
					access : {
						groups : ["default"],
						permissions : ["send_message", "receive_message", "upload_file", "download_file"]
					},
					banned : false
				};

				let serialized_data = JSON.stringify(data, null, 2);

				fs.writeFile(filepath, serialized_data, (err) => {
					if(err) {
						var1.callback.call(void(0), "translate:system/internal_error");
						return;
					}

					var1.callback.call(void(0), void(0), data);
				});

				return;
			}

			var1.callback.call(void(0), "translate:user/already_existing_user");
		});
	};
};

User._users = [];

module.exports = User;

let ChannelManager = require('core/channelmanager');