const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
let SocketServer = require('core/socketserver');

class User {
	/**
	 * @constructor
	 * @param {Object} var1
	 */
	constructor(var1) {
		this._socket = var1.socket;
		this._username = var1.username;
		this._avatar = var1.avatar;
		this._group = null;
		this._permissions = null;
	};

	/**
	 * @param {Websocket} var1
	 */
	setSocket(var1) {
		this._socket = var1;
	};

	/**
	 * @param {string} var1
	 */
	setUsername(var1) {
		this._username = var1;
	};

	/**
	 * @param {integer} var1
	 */
	setAvatar(var1) {
		this._avatar = var1;
	};

	/**
	 * @param {Group} var1
	 */
	setGroup(var1) {
		this._group = var1;
	};

	/**
	 * @param {Array.<string>} var1
	 */
	setPermissions(var1) {
		this._permissions = var1;
	};

	/**
	 * @return {WebSocket}
	 */
	getSocket() {
		return this._socket;
	};

	/**
	 * @return {string}
	 */
	getUsername() {
		return this._username;
	};

	getAvatar() {
		return this._avatar;
	};

	getGroup() {
		return this._group;
	};

	getPermissions() {
		return this._permissions;
	};

	/**
	 * @param {String} var1
	 */
	notify(var1) {
		this._socket.send(var1);
	};

	/**
	 * @param {Object} var1
	 * @param {string} var1.username
	 * @param {string} var1.password
	 */
	signin(var1) {
		let self = this;

		if(!(typeof var1.username === 'string' && typeof var1.password === 'string')) {
			self.notify(JSON.stringify({
				action : "signin_failed",
				extra : {
					message : "translate:user/bad_request"
				}
			}));
			return;
		}

		User.validateCredentials({
			username : var1.username,
			password : var1.password,
			callback : (err, user_data) => {
				if(err) {
					self.notify(JSON.stringify({
						action : "signin_failed",
						extra : {
							message : err
						}
					}));
					return;
				}

				self.setUsername(user_data.username);
				self.setAvatar(user_data.avatar);
				self.setGroup(user_data.group);
				self.setPermissions(user_data.permissions);

				self.notify(JSON.stringify({
					action : "signin_success",
					extra : {
						message : "translate:user/signin_success",
						username : self.getUsername(),
						avatar : self.getAvatar()
					}
				}));
			}
		});
	};

	/**
	 * @param {Object}
	 */
	signup(var1) {
		let self = this;

		if(!(typeof var1.username === 'string' && typeof var1.password === 'string')) {
			self.notify(JSON.stringify({
				action : "signup",
				extra : {
					message : "translate:user/bad_request"
				}
			}));
			return;
		}

		User.registerUser({
			username : var1.username,
			password : var1.password,
			callback : (err, user_data) => {
				if(err) {
					self.notify(JSON.stringify({
						action : "signup_failed",
						extra : {
							message : err
						}
					}));

					return;
				}

				self.setUsername(user_data.username);
				self.setAvatar(user_data.avatar);
				self.setGroup(user_data.group);
				self.setPermissions(user_data.permissions);

				self.notify(JSON.stringify({
					action : "signup_success",
					extra : {
						message : "translate:user/signup_success",
						username : self.getUsername(),
						avatar : self.getAvatar()
					}
				}));
			}
		});
	};

	signout(var1) {
		let self = this;

		User.removeUser({
			socket : this.getSocket(),
			callback : (err) => {
				if(err) {
					return;
				}

				self.notify({
					"action" : "signout_success",
					extra : {
						message : "translate:user/signout_success"
					}
				});
			}
		});
	};

	/**
	 * @param {WebSocket} var1
	 */
	static addUser(var1) {
		let user;
		this._users[var1] = user = new User({ socket : var1 });

		var1.on('message', (data) => {
			let parsed_data;

			try {
				parsed_data = JSON.parse(data);
			} catch (e) {
				return;
			}

			let action = parsed_data.action;

			switch(action) {
				case "signup" :
					user.signup(parsed_data.extra);
					break;
				
				case "signin" :
					user.signin(parsed_data.extra);
					break;

				case "signout" :
					user.signout(parsed_data.extra);
					break;

				case "upload_init" :
					break;

				case "upload_chunk" :
					break;
				
				case "upload_finished" :
					break;

				default:
			}
		});

		var1.on('close', () => {
			this.removeUser(var1);
		});
	};

	/**
	 * @param {Object} var1
	 * @param {WebSocket} var1.socket
	 * @param {requestCallback} var1.callback
	 */
	static removeUser(var1) {
		let user = this.getUser(var1.socket);
		delete this._users[var1];

		if(typeof user === 'undefined') {
			return;
		}

		var1.callback.call();

		user.getChannel().remove(user);
	};

	/**
	 * @param {WebSocket}
	 */
	static getUser(var1) {
		return this._users[var1];
	};

	/**
	 * @param {Object} var1
	 * @param {string} var1.username
	 * @param {string} var1.password
	 * @param {requestCallback} var1.callback
	 */
	static validateCredentials(var1) {
		let username = var1.username.toLowerCase();
		let password = var1.password;

		if(!(/[A-z][A-z0-9_]+/.test(username))) {
			var1.callback.call(void(0), "translate:user/invalid_username_format");
			return;
		}

		let filepath = path.normalize(process.cwd() + '/server/users/' + username + '.json');
		
		fs.readFile(filepath, (err, data) => {
			if(err) {
				var1.callback.call(void(0), "translate:user/unknown_user");
				return;
			}

			let parsed_data;

			try {
				parsed_data = JSON.parse(data);
			} catch(e) {
				// should not be emitted
				// this error only appear when there is an error with (user) JSON file
				var1.callback.call(void(0), "translate:user/invalid_file_serializing");
				return;
			}

			if(!(parsed_data.password === crypto.createHash("sha256").update(password).update(username).digest("base64"))) {
				var1.callback.call(void(0), "translate:user/invalid_password");
				return;
			}

			if(parsed_data.banned) {
				var1.callback.call(void(0), "translate:user/user_suspended");
				return;
			}

			var1.callback.call(void(0), null, parsed_data);
		});
	};

	/**
	 * @param {Object} var1
	 * @param {string} var1.username
	 * @param {string} var1.password
	 * @param {requestCallback} var1.callback
	 */
	static registerUser(var1) {
		let username = var1.username.toLowerCase();
		let password = var1.password;

		if(!(/[A-z][A-z0-9_]+/.test(username))) {
			var1.callback.call(void(0), "translate:user/invalid_username_format");
			return;
		}

		let filepath = path.normalize(process.cwd() + '/server/users/' + username + '.json');

		fs.stat(filepath, (err, stats) => {
			if(err) {
				let data = {
					username : username,
					password : crypto.createHash("sha256").update(password).update(username).digest("base64"),
					avatar : "0",
					access : {
						groups : ["default"],
						permissions : ["send_message", "receive_message", "upload_file", "download_file"]
					},
					banned : false
				};

				let serialized_data = JSON.stringify(data, null, 2);

				fs.writeFile(filepath, serialized_data, (err) => {
					if(err) {
						var1.callback.call(void(0), "translate:system/internal_error");
						return;
					}

					var1.callback.call(void(0), void(0), data);
				});

				return;
			}

			var1.callback.call(void(0), "translate:user/already_existing_user");
		});
	};
};

User._users = {};

module.exports = User;