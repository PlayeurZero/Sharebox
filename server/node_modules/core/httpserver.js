String.prototype.ltrim = function(var1) { var1 = var1 || ' '; return this.replace(new RegExp('^[' + var1 + ']+'), ''); };
String.prototype.rtrim = function(var1) { var1 = var1 || ' '; return this.replace(new RegExp('[' + var1 + ']+$'), ''); };
String.prototype.trim = function(var1) { return this.ltrim(var1).rtrim(var1); };

let http = require('http');
let fs = require('fs');
let zlib = require('zlib');
const path = require('path');
const url = require('url');

class HTTPServer {
	constructor() {
		this.setOptions({ port : 8080, compression : { enabled : true } });
	};

	setOptions(options) {
		this._options = Object.assign(this._options || {}, options);
	};

	getOptions() {
		return this._options;
	};

	run() {
		let options = this.getOptions();

		let server = http.createServer();
		server.on('request', (req, res) => {
			let parsed_url = url.parse(req.url, true);

			let pathname = parsed_url.pathname.trim('/');

			if(pathname == '') this.client(req, res, 'index.html');

			else if(pathname == 'download' && parsed_url.query.file) this.download(req, res, parsed_url.query.file, parsed_url.query.name);
			else this.client(req, res, parsed_url.pathname);
		});

		server.listen(options.port);
	};

	client(req, res, pathname) {
		let options = this.getOptions();

		let file = path.normalize(options.folders.client + '/' + pathname);
		let extension = path.extname(file).substr(1);
		let content_type = HTTPServer.getContentType(extension);

		fs.readFile(file, (err, data) => {
			if(err) {
				res.writeHead(404, {});
				res.end();

				return;
			}

			if(options.compression.enabled) {
				let accept_encoding = req.headers['accept-encoding'] || '';

				if(accept_encoding.match(/\bdeflate\b/)) {
					zlib.deflate(data, (err, buffer) => {
						if(err) {
							res.writeHead(406, {});
							res.end();

							return;
						}

						res.writeHead(200, {
							"Content-Type" : content_type,
							"Content-Encoding" : "deflate"
						});

						res.write(buffer);
						res.end();
						return;
					});
				} else if(accept_encoding.match(/\bgzip\b/)) {
					zlib.gzip(data, (err, buffer) => {
						if(err) {
							res.writeHead(406, {});
							res.end();

							return;
						}

						res.writeHead(200, {
							"Content-Type" : content_type,
							"Content-Encoding" : "gzip"
						});

						res.write(buffer);
						res.end();
						return;
					});
				} else {
					res.writeHead(200, {
						"Content-Type" : content_type
					});

					res.write(data);
					res.end();
					return;
				}
			} else {
				res.writeHead(200, {
					"Content-Type" : content_type
				});

				res.write(data);
				res.end();
				return;
			}
		});
	};

	download(req, res, filename, name) {
		let options = this.getOptions();

		let file = path.normalize(options.folders.download + '/' + filename);
		name = decodeURIComponent(name) || 'download'; 
		
		fs.readFile(file, (err, data) => {
			if(err) {
				res.writeHead(404, {});
				res.end();

				return;
			}

			res.writeHead(200, {
				'Content-Disposition' : 'attachment; filename="' + name + '"'
			});

			res.write(data);

			res.end();
		});
	};

	static getContentType(extension) {
		let types = this._types;
		
		if(types[extension]) return types[extension];
		return types.default;
	};

	static getInstance() {
		if(this._instance === null) {
			this._instance = new HTTPServer();
		}

		return this._instance;
	};
};

HTTPServer._instance = null;
HTTPServer._types = {
	'html' : 'text/html',
	'css' : 'text/css',
	'js' : 'application/x-javascript',
	'zip' : 'application/x-zip-compressed',
	'woff' : 'application/x-font-woff',
	'woff2' : 'application/font-woff2',
	'ttf' : 'application/x-font-truetype',
	'otf' : 'application/x-font-opentype',
	'eot' : 'application/vnd.ms-fontobject',
	'svg' : 'image/svg+xml',
	'png' : 'image/png',
	'jpg' : 'image/jpeg',
	'jpeg' : 'image/jpeg',
	'bmp' : 'image/bmp',
	'avi' : 'video/avi',
	'mp3' : 'audio/mpeg3',
	'mpg' : 'video/mpeg',
	'mpeg' : 'video/mpeg',
	'default': 'application/octet-stream'
};

module.exports = HTTPServer;